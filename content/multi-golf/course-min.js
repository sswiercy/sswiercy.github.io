const course={constants:{COLORS:{GREEN:new game.model.Color(.4,.8,.2),WALL:new game.model.Color(.8,.8,.8),HOLE:new game.model.Color(1,1,1)},COLLISION:{GREEN:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.5,.001,.05),WALL:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.7,.001,.02),HOLE:{WALL:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.3,.001,.1),FLOOR:new game.collision.handlers.Collection([new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.3,.001,.2),game.collision.handlers.Static.BALL_COMPLETION])}},CURVE_STEPS:12,NORMAL_DELTA:.01},parts:{walls:{straight:function(e,t,o){const r=Math.tan(t),a=Math.tan(o);return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,e+a,-2),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL),opposite:11},{vertex:new game.model.Vertex(new game.geometry.Vector(1,e+a,1),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,e+a,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:9},{vertex:new game.model.Vertex(new game.geometry.Vector(2,e,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,e,1),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL),opposite:7},{vertex:new game.model.Vertex(new game.geometry.Vector(2,e,0),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(1,-r,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,-r,1),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(1,-r,-2),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL)},curveOuter:function(e,t,o){const r=game.model.Path.circle(e,t,o).withColor(course.constants.COLORS.WALL),a=game.model.Path.circle(e,t,o).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,1))),m=game.model.Path.circle(e+1,t,o).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,1))),n=game.model.Path.circle(e+1,t,o).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2)));return game.physics.Body.fromModel(r.stripe(a).concat(a.stripe(m)).concat(m.stripe(n)),course.constants.COLLISION.WALL)},pathBorder:function(e,t){const o=e.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),r=o.border(t,0,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),a=o.border(t,1,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=o.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),n=o.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.physics.Body.fromModel(m.stripe(a).concat(a.stripe(r)).concat(r.stripe(o)).concat(game.model.Triangle.polygon([{vertex:n.mapper(0).negateNormal(),opposite:2},{vertex:m.mapper(0).negateNormal()},{vertex:a.mapper(0).negateNormal(),opposite:0},{vertex:r.mapper(0).negateNormal()}])).concat(game.model.Triangle.polygon([{vertex:r.mapper(1),opposite:2},{vertex:a.mapper(1)},{vertex:m.mapper(1),opposite:0},{vertex:n.mapper(1)}])),course.constants.COLLISION.WALL)},straightCap:function(e){return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:7},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,0),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,-2),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,-2),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:2}]),course.constants.COLLISION.WALL)}},hole:function(e,t,o){return course.parts.walls.curveOuter(e/2,Math.PI,2*course.constants.CURVE_STEPS).merge(course.parts.walls.straight(e/2+t+2,0,0).merge(course.parts.walls.straightCap(e)).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-e/2-2,-e/2-t-2,0)))).merge(course.parts.walls.straight(e/2+t+2,0,0).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e/2+2,0,0))))).merge(game.physics.Body.fromModel(game.model.Triangle.stripe(game.model.Path.circle(e/2+1,Math.PI,2*course.constants.CURVE_STEPS).withNormal(new game.geometry.Vector(0,0,-1)).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2))).waypoints(),[new game.model.Vertex(new game.geometry.Vector(e/2+1,-e/2-t-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),new game.model.Vertex(new game.geometry.Vector(-e/2-1,-e/2-t-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)).merge(game.physics.Body.fromModel(game.model.Path.circle(o,Math.PI,course.constants.CURVE_STEPS).withColor(course.constants.COLORS.GREEN).enableChecker().stripe(game.model.Path.circle(e/2,Math.PI,2*course.constants.CURVE_STEPS).withColor(course.constants.COLORS.GREEN).enableChecker()).concat(game.model.Triangle.stripe(game.model.Path.circle(o,Math.PI,course.constants.CURVE_STEPS).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(Math.PI)).waypoints(),[new game.model.Vertex(new game.geometry.Vector(-e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(-e/2,-e/2-t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,-e/2-t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)])),course.constants.COLLISION.GREEN)).merge(game.physics.Body.fromModel(game.model.Path.circle(o,2*Math.PI,2*course.constants.CURVE_STEPS).withColor(course.constants.COLORS.HOLE).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-1))).stripe(game.model.Path.circle(o,2*Math.PI,2*course.constants.CURVE_STEPS).withColor(course.constants.COLORS.HOLE)),course.constants.COLLISION.HOLE.WALL)).merge(game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(-o,-o,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(-o,o,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(o,o,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(o,-o,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.HOLE.FLOOR))},straight:function(e,t){return course.parts.verticalPath(e,t,(function(e){return 0}),1)},rectEnd:function(e,t){return course.parts.walls.straight(t-2,0,Math.PI/4).merge(course.parts.walls.straight(t-2,Math.PI/4,0).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-2,0))))).merge(course.parts.walls.straight(e,Math.PI/4,Math.PI/4).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0))))).merge(course.parts.walls.straightCap(e)).merge(game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)}]),course.constants.COLLISION.GREEN)).merge(game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,t-1,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(1,t-1,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL))},rectCurve:function(e,t,o,r){return course.parts.walls.straight(t-2,0,Math.PI/4).merge(course.parts.walls.straight(r-2,Math.PI/4,0).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0))))).merge(course.parts.walls.straight(t-o-2,-Math.PI/4,0).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-o-2,0))))).merge(course.parts.walls.straight(r-e-2,0,-Math.PI/4).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(r,t-o-4,0))))).merge(course.parts.walls.straightCap(e)).merge(course.parts.walls.straightCap(o).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(r,t-o-4,0))))).merge(game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:4},{vertex:new game.model.Vertex(new game.geometry.Vector(2,t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:4},{vertex:new game.model.Vertex(new game.geometry.Vector(r,t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:4},{vertex:new game.model.Vertex(new game.geometry.Vector(r,t-o-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,t-o-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)}]),course.constants.COLLISION.GREEN)).merge(game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,t-o-3,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(r,t-o-3,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(r,t-1,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(1,t-1,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL))},horizontalCurve:function(e,t,o){return course.parts.stripe(game.model.Path.circle(t,o,course.constants.CURVE_STEPS/2).position(),game.model.Path.circle(t+e,o,course.constants.CURVE_STEPS).position())},verticalCurve:function(e,t,o){return course.parts.stripe(game.model.Path.circle(t,o,course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationY(Math.PI/2)).position(),game.model.Path.circle(t,o,course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationY(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e,0,0)))).position())},verticalPath:function(e,t,o,r){return course.parts.stripe(new game.model.Path((function(e){return new game.geometry.Vector(2,t*e,o(e))}),r),new game.model.Path((function(r){return new game.geometry.Vector(2+e,t*r,o(r))}),r))},stripe:function(e,t){const o=e.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),r=t.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),a=o.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=r.border(e,1,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),n=o.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),s=r.border(e,0,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.physics.Body.fromModel(o.withColor(course.constants.COLORS.GREEN).enableChecker().stripe(r.withColor(course.constants.COLORS.GREEN).enableChecker()),course.constants.COLLISION.GREEN).merge(game.physics.Body.fromModel(m.stripe(a).concat(game.model.Triangle.polygon([{vertex:o.mapper(0).negateNormal(),opposite:2},{vertex:r.mapper(0).negateNormal()},{vertex:s.mapper(0).negateNormal(),opposite:0},{vertex:n.mapper(0).negateNormal()}])).concat(game.model.Triangle.polygon([{vertex:n.mapper(1),opposite:2},{vertex:s.mapper(1)},{vertex:r.mapper(1),opposite:0},{vertex:o.mapper(1)}])),course.constants.COLLISION.WALL)).merge(course.parts.walls.pathBorder(e,t)).merge(course.parts.walls.pathBorder(t.reverse(),e.reverse()))}},compositions:{simpleStraight:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,49,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),course.parts.rectEnd(10,56).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,0))).merge(course.parts.hole(10,0,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(7,-7,0))))))},verticalCurveOver:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,21,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),course.parts.rectEnd(10,28).merge(course.parts.verticalCurve(10,14,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(12,0,14))))).merge(course.parts.horizontalCurve(10,9,Math.PI/2).transform(game.geometry.Matrix.rotationX(Math.PI/2).dot(game.geometry.Matrix.rotationZ(Math.PI)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-14,14))))).merge(course.parts.horizontalCurve(10,9,Math.PI/2).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.rotationX(-Math.PI/2)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-14,14))))).merge(course.parts.verticalCurve(10,14,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(40,0,14))))).merge(course.parts.rectCurve(10,14,10,14).transform(game.geometry.Matrix.translation(new game.geometry.Vector(14,14,0)))).merge(course.parts.rectCurve(10,14,10,28).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(28,28,0))))).merge(course.parts.hole(10,14,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-7,0))))))},crossJump:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,7,7),new game.geometry.Vector(0,0,0)),course.parts.rectEnd(10,28).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,0))).merge(course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(14,-14,0))))).merge(course.parts.verticalPath(10,28,(function(e){return 1-Math.cos(4*Math.PI*e)}),2*course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-28,0))))).merge(course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0))))).merge(course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0)))).merge(course.parts.verticalPath(10,28,(function(e){return 6*Math.pow(e,2)}),course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0))))).merge(course.parts.straight(10,14).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,4))))).merge(course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-14,-14,4))))).merge(course.parts.hole(10,0,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-21,-21,4))))))}}};"undefined"!=typeof exports&&(module.exports=course);