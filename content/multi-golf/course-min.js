const course={constants:{COLORS:{GREEN:new game.model.Color(.4,.8,.2),WALL:new game.model.Color(.8,.8,.8),HOLE:new game.model.Color(1,1,1)},COLLISION:{GREEN:new game.collision.handlers.Rebound(1,1/3,.5,10),WALL:new game.collision.handlers.Rebound(1,1/3,.75,7.5),HOLE:{WALL:new game.collision.handlers.Rebound(1,1/3,.2,20),FLOOR:new game.collision.handlers.Collection([new game.collision.handlers.Rebound(1,1/3,.2,20),new game.collision.handlers.Completion])}},CURVE_STEPS:12,NORMAL_DELTA:.01},parts:{walls:{straight:function(e,t,o){const r=Math.tan(t),a=Math.tan(o);return game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,e+a,-2),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL),opposite:11},{vertex:new game.model.Vertex(new game.geometry.Vector(1,e+a,1),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,e+a,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:9},{vertex:new game.model.Vertex(new game.geometry.Vector(2,e,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,e,1),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL),opposite:7},{vertex:new game.model.Vertex(new game.geometry.Vector(2,e,0),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(1,0,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(1,-r,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,-r,1),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(1,-r,-2),new game.geometry.Vector(-1,0,0),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL)},curveOuter:function(e,t,o){const r=game.model.Path.circle(e,t,o).withColor(course.constants.COLORS.WALL),a=game.model.Path.circle(e,t,o).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,1))),n=game.model.Path.circle(e+1,t,o).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,1))),m=game.model.Path.circle(e+1,t,o).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2)));return game.Body.fromModel(r.stripe(a).concat(a.stripe(n)).concat(n.stripe(m)),course.constants.COLLISION.WALL)},pathBorder:function(e,t){const o=e.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),r=o.border(t,0,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),a=o.border(t,1,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),n=o.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=o.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.Body.fromModel(n.stripe(a).concat(a.stripe(r)).concat(r.stripe(o)).concat(game.model.Triangle.polygon([{vertex:m.mapper(0).negateNormal(),opposite:2},{vertex:n.mapper(0).negateNormal()},{vertex:a.mapper(0).negateNormal(),opposite:0},{vertex:r.mapper(0).negateNormal()}])).concat(game.model.Triangle.polygon([{vertex:r.mapper(1),opposite:2},{vertex:a.mapper(1)},{vertex:n.mapper(1),opposite:0},{vertex:m.mapper(1)}])),course.constants.COLLISION.WALL)},straightCap:function(e){return game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:7},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,0),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,1),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,-2),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,-2),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WALL),opposite:2}]),course.constants.COLLISION.WALL)}},hole:function(e,t){return course.parts.walls.curveOuter(e/2,Math.PI,2*course.constants.CURVE_STEPS).merge(course.parts.walls.straight(e/2+2,0,0).merge(course.parts.walls.straightCap(e)).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-e/2-2,-e/2-2,0)))).merge(course.parts.walls.straight(e/2+2,0,0).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e/2+2,0,0))))).merge(game.Body.fromModel(game.model.Triangle.stripe(game.model.Path.circle(e/2+1,Math.PI,2*course.constants.CURVE_STEPS).withNormal(new game.geometry.Vector(0,0,-1)).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2))).waypoints(),[new game.model.Vertex(new game.geometry.Vector(e/2+1,-e/2-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),new game.model.Vertex(new game.geometry.Vector(-e/2-1,-e/2-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)).merge(game.Body.fromModel(game.model.Path.circle(t,Math.PI,course.constants.CURVE_STEPS).withColor(course.constants.COLORS.GREEN).enableChecker().stripe(game.model.Path.circle(e/2,Math.PI,2*course.constants.CURVE_STEPS).withColor(course.constants.COLORS.GREEN).enableChecker()).concat(game.model.Triangle.stripe(game.model.Path.circle(t,Math.PI,course.constants.CURVE_STEPS).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(Math.PI)).waypoints(),[new game.model.Vertex(new game.geometry.Vector(-e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(-e/2,-e/2-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,-e/2-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)])),course.constants.COLLISION.GREEN)).merge(game.Body.fromModel(game.model.Path.circle(t,2*Math.PI,2*course.constants.CURVE_STEPS).withColor(course.constants.COLORS.HOLE).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-1))).stripe(game.model.Path.circle(t,2*Math.PI,2*course.constants.CURVE_STEPS).withColor(course.constants.COLORS.HOLE)),course.constants.COLLISION.HOLE.WALL)).merge(game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(-t,-t,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(-t,t,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(t,t,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(t,-t,-1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.HOLE.FLOOR))},straight:function(e,t){return course.parts.walls.straight(t,0,0).merge(course.parts.walls.straightCap(e)).merge(course.parts.walls.straight(t,0,0).merge(course.parts.walls.straightCap(e)).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t,0))))).merge(game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,t,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,t,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)}]),course.constants.COLLISION.GREEN)).merge(game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,t,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(1,t,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL))},rectEnd:function(e,t){return course.parts.walls.straight(t-2,0,Math.PI/4).merge(course.parts.walls.straightCap(e)).merge(course.parts.walls.straight(t-2,Math.PI/4,0).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-2,0))))).merge(course.parts.walls.straight(e,Math.PI/4,Math.PI/4).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0))))).merge(game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e+2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)}]),course.constants.COLLISION.GREEN)).merge(game.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,0,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(e+3,t-1,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(1,t-1,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL))},bend:function(e,t,o){return course.parts.stripe(game.model.Path.circle(t,o,course.constants.CURVE_STEPS/2).position(),game.model.Path.circle(t+e,o,course.constants.CURVE_STEPS).position())},verticalPath:function(e,t,o,r){return course.parts.stripe(new game.model.Path((function(e){return new game.geometry.Vector(2,t*e,o(e))}),r),new game.model.Path((function(r){return new game.geometry.Vector(2+e,t*r,o(r))}),r))},stripe:function(e,t){const o=e.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),r=t.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),a=o.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),n=r.border(e,1,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=o.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),s=r.border(e,0,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.Body.fromModel(o.withColor(course.constants.COLORS.GREEN).enableChecker().stripe(r.withColor(course.constants.COLORS.GREEN).enableChecker()),course.constants.COLLISION.GREEN).merge(game.Body.fromModel(n.stripe(a).concat(game.model.Triangle.polygon([{vertex:o.mapper(0).negateNormal(),opposite:2},{vertex:r.mapper(0).negateNormal()},{vertex:s.mapper(0).negateNormal(),opposite:0},{vertex:m.mapper(0).negateNormal()}])).concat(game.model.Triangle.polygon([{vertex:m.mapper(1),opposite:2},{vertex:s.mapper(1)},{vertex:r.mapper(1),opposite:0},{vertex:o.mapper(1)}])),course.constants.COLLISION.WALL)).merge(course.parts.walls.pathBorder(e,t)).merge(course.parts.walls.pathBorder(t.reverse(),e.reverse()))}},compositions:{test:function(){return course.parts.rectEnd(10,14).merge(course.parts.straight(10,14).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,0)))).merge(course.parts.bend(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(14,-14,0))))).merge(course.parts.verticalPath(10,28,(function(e){return 1-Math.cos(4*Math.PI*e)}),2*course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-28,0))))).merge(course.parts.bend(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0))))).merge(course.parts.bend(10,2,Math.PI/2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0)))).merge(course.parts.verticalPath(10,28,(function(e){return 6*Math.pow(e,2)}),course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0))))).merge(course.parts.straight(10,14).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,4))))).merge(course.parts.bend(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-14,-14,4))))).merge(course.parts.hole(10,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-21,-21,4)))))}}};