const course={constants:{COLORS:{GREEN:new game.model.Color(.4,.8,.2),WALL:new game.model.Color(.8,.8,.8),WOOD:new game.model.Color(.7,.5,0),HOLE:new game.model.Color(1,1,1)},COLLISION:{GREEN:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.4,.001,.05),WALL:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.7,.001,.02),WOOD:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.5,.001,.04),HOLE:{WALL:new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.3,.001,.1),FLOOR:new game.collision.handlers.Collection([new game.collision.handlers.Rebound(game.physics.Ball.MIN_VELOCITY,.1,.3,.001,.2),game.collision.handlers.Static.BALL_COMPLETION])}},CURVE_STEPS:12,NORMAL_DELTA:.01},utility:{curveSteps:function(e){return Math.max(Math.round(course.constants.CURVE_STEPS*e),1)},stepsByAngle:function(e){return course.utility.curveSteps(Math.abs(e)/Math.PI)}},parts:{quads:{xp:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[0],o[0]),new game.geometry.Vector(1,0,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[1],a[0]),new game.geometry.Vector(1,0,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[1],a[1]),new game.geometry.Vector(1,0,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[0],o[1]),new game.geometry.Vector(1,0,0),n,m)}])},xn:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[0],o[1]),new game.geometry.Vector(-1,0,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[1],a[1]),new game.geometry.Vector(-1,0,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[1],a[0]),new game.geometry.Vector(-1,0,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[0],o[0]),new game.geometry.Vector(-1,0,0),n,m)}])},yp:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],e,o[1]),new game.geometry.Vector(0,1,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],e,a[1]),new game.geometry.Vector(0,1,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],e,a[0]),new game.geometry.Vector(0,1,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],e,o[0]),new game.geometry.Vector(0,1,0),n,m)}])},yn:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],e,o[0]),new game.geometry.Vector(0,-1,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],e,a[0]),new game.geometry.Vector(0,-1,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],e,a[1]),new game.geometry.Vector(0,-1,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],e,o[1]),new game.geometry.Vector(0,-1,0),n,m)}])},zp:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],o[0],e),new game.geometry.Vector(0,0,1),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],a[0],e),new game.geometry.Vector(0,0,1),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],a[1],e),new game.geometry.Vector(0,0,1),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],o[1],e),new game.geometry.Vector(0,0,1),n,m)}])},zn:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],o[1],e),new game.geometry.Vector(0,0,-1),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],a[1],e),new game.geometry.Vector(0,0,-1),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],a[0],e),new game.geometry.Vector(0,0,-1),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],o[0],e),new game.geometry.Vector(0,0,-1),n,m)}])}},walls:{straight:function(e,t){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.xn(1,[e[0],e[0]],[t[0],t[0]],[-2,-2],[1,1],course.constants.COLORS.WALL),course.parts.quads.zp(1,[1,1],[2,2],e,t,course.constants.COLORS.WALL),course.parts.quads.xp(2,[e[1],e[1]],[t[1],t[1]],[0,0],[1,1],course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)},elbowLeft:function(e,t){const r=Math.tan(e/2),o=Math.cos(e),a=Math.sin(e);return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2,r,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1+o,a,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1+o,a,1),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(1+o,a,t),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,r,t),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(2,r,1),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL)},elbowRight:function(e,t){const r=Math.tan(e/2),o=Math.cos(e),a=Math.sin(e);return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2-o,a,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,r,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,r,1),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(1,r,t),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2-o,a,t),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(2-o,a,1),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL)},elbowBoth:function(e,t,r){return e>0?course.parts.walls.elbowRight(e,t):e<0?course.parts.walls.elbowLeft(-e,r):game.physics.Body.EMPTY},straightElbowed:function(e,t,r){const o=Math.tan(t/2),a=Math.tan(r/2);return game.physics.Body.merge([course.parts.walls.straight([Math.min(-o,0),Math.min(o,0)],[e+Math.max(a,0),e+Math.max(-a,0)]),course.parts.walls.elbowBoth(-t,0,-2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(3,0,0)))),course.parts.walls.elbowBoth(r,-2,0).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,e,0)))])},pathBorder:function(e,t,r,o){const a=e.withColor(course.constants.COLORS.WALL),n=a.border(t,0,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=a.border(t,1,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),s=a.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),g=a.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.physics.Body.fromModel(game.utility.flatten([s.stripe(m),m.stripe(n),n.stripe(a),r?game.model.Triangle.polygon([{vertex:g.mapper(0).negateNormal(),opposite:2},{vertex:s.mapper(0).negateNormal()},{vertex:m.mapper(0).negateNormal(),opposite:0},{vertex:n.mapper(0).negateNormal()}]):[],o?game.model.Triangle.polygon([{vertex:n.mapper(1),opposite:2},{vertex:m.mapper(1)},{vertex:s.mapper(1),opposite:0},{vertex:g.mapper(1)}]):[]]),course.constants.COLLISION.WALL)},straightCap:function(e){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.yn(0,[1,1],[2,2],[-2,0],[1,1],course.constants.COLORS.WALL),course.parts.quads.yn(0,[1,2],[e+3,e+2],[-2,-2],[0,0],course.constants.COLORS.WALL),course.parts.quads.yn(0,[e+2,e+2],[e+3,e+3],[0,-2],[1,1],course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)}},woods:{straight:function(e,t,r){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.yn(0,e.slice(0,2),t.slice(0,2),[0,0],[1,1],course.constants.COLORS.WOOD),course.parts.quads.zp(1,e.slice(1,3),t.slice(1,3),[0,0],[r,r],course.constants.COLORS.WOOD),course.parts.quads.yp(r,e.slice(2,4).reverse(),t.slice(2,4).reverse(),[0,0],[1,1],course.constants.COLORS.WOOD)]),course.constants.COLLISION.WOOD)},cap:function(e,t,r,o){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.xp(0,[0,0],[e,e],[0,0],[r,r],course.constants.COLORS.WOOD),[new game.model.Triangle(new game.model.Vertex(new game.geometry.Vector(0,0,r),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(0,0,0),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(-t,0,o),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WOOD)),new game.model.Triangle(new game.model.Vertex(new game.geometry.Vector(0,e,0),new game.geometry.Vector(0,1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(0,e,r),new game.geometry.Vector(0,1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(-t,e,o),new game.geometry.Vector(0,1,0),course.constants.COLORS.WOOD))]]),course.constants.COLLISION.WOOD)},arc:function(e,t,r,o,a){const n=game.model.Path.circle(e,Math.PI,a).withColor(course.constants.COLORS.WOOD).transform(game.geometry.Matrix.rotationX(Math.PI/2)),m=game.model.Path.circle(t,Math.PI,a).withColor(course.constants.COLORS.WOOD).transform(game.geometry.Matrix.rotationX(Math.PI/2)),s=n.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,o))),g=n.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,r,o))),c=m.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,o))),i=m.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,r,o)));return game.physics.Body.fromModel(game.utility.flatten([s.stripe(c),c.stripe(i),i.stripe(g),g.stripe(s)]),course.constants.COLLISION.WOOD)}},hole:function(e,t,r){const o=game.model.Path.circle(e,2*Math.PI,r),a=game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-t));return game.physics.Body.merge([game.physics.Body.fromModel(o.withColor(course.constants.COLORS.HOLE).transform(a).stripe(o.withColor(course.constants.COLORS.HOLE)),course.constants.COLLISION.HOLE.WALL),game.physics.Body.fromModel(o.withColor(course.constants.COLORS.WALL).withNormal(new game.geometry.Vector(0,0,1)).transform(a).reverse().truncate(1).fan(),course.constants.COLLISION.HOLE.FLOOR)])},roundHoleEnd:function(e,t,r){return game.physics.Body.merge([course.parts.walls.pathBorder(game.model.Path.circle(e/2,Math.PI,course.utility.curveSteps(2)).reverse().negateNormals(),game.model.Path.point(new game.geometry.Vector(0,0,0))),game.physics.Body.merge([course.parts.walls.straight([0,0],[e/2+t+2,e/2+t+2]),course.parts.walls.straightCap(e)]).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-e/2-2,-e/2-t-2,0))),course.parts.walls.straight([0,0],[e/2+t+2,e/2+t+2]).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e/2+2,0,0)))),game.physics.Body.fromModel(game.model.Triangle.stripe(game.model.Path.circle(e/2+1,Math.PI,course.utility.curveSteps(2)).withNormal(new game.geometry.Vector(0,0,-1)).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2))).waypoints(),[new game.model.Vertex(new game.geometry.Vector(e/2+1,-e/2-t-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),new game.model.Vertex(new game.geometry.Vector(-e/2-1,-e/2-t-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL),game.physics.Body.fromModel(game.utility.flatten([game.model.Path.circle(r,Math.PI,course.constants.CURVE_STEPS).withColor(course.constants.COLORS.GREEN).enableChecker().stripe(game.model.Path.circle(e/2,Math.PI,course.utility.curveSteps(2)).withColor(course.constants.COLORS.GREEN).enableChecker()),game.model.Triangle.stripe(game.model.Path.circle(r,Math.PI,course.constants.CURVE_STEPS).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(Math.PI)).waypoints(),[new game.model.Vertex(new game.geometry.Vector(-e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(-e/2,-e/2-t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,-e/2-t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)])]),course.constants.COLLISION.GREEN),course.parts.hole(r,1,course.utility.curveSteps(2))])},straight:function(e,t){return course.parts.verticalPath(e,t,(function(e){return 0}),1)},rectEnd:function(e,t){return game.physics.Body.merge([course.parts.walls.straight([0,0],[t-1,t-2]),course.parts.walls.straight([-1,0],[t-2,t-2]).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-2,0)))),course.parts.walls.straight([-1,0],[e+1,e]).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0)))),course.parts.walls.straightCap(e),game.physics.Body.fromModel(course.parts.quads.zp(0,[2,2],[e+2,e+2],[0,0],[t-2,t-2],course.constants.COLORS.GREEN,!0),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(course.parts.quads.zn(-2,[1,1],[e+3,e+3],[0,0],[t-1,t-1],course.constants.COLORS.WALL),course.constants.COLLISION.WALL)])},rectCurve:function(e,t,r,o){return game.physics.Body.merge([course.parts.walls.straight([0,0],[t-1,t-2]),course.parts.walls.straight([-1,0],[o-2,o-2]).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0)))),course.parts.walls.straight([1,0],[t-r-2,t-r-2]).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-r-2,0)))),course.parts.walls.straight([0,0],[o-e-3,o-e-2]).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(o,t-r-4,0)))),course.parts.walls.straightCap(e),course.parts.walls.straightCap(r).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(o,t-r-4,0)))),game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.zp(0,[2,2],[e+2,e+2],[0,0],[t-2,t-r-2],course.constants.COLORS.GREEN,!0),course.parts.quads.zp(0,[e+2,2],[o,o],[t-r-2,t-r-2],[t-2,t-2],course.constants.COLORS.GREEN,!0)]),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.zn(-2,[1,1],[e+3,e+3],[0,0],[t-1,t-r-3],course.constants.COLORS.WALL),course.parts.quads.zn(-2,[e+3,1],[o,o],[t-r-3,t-r-3],[t-1,t-1],course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)])},horizontalCurve:function(e,t,r){const o=course.utility.stepsByAngle(r);return course.parts.stripe(game.model.Path.circle(t,r,o).position(),game.model.Path.circle(t+e,r,2*o).position())},verticalCurve:function(e,t,r){const o=course.utility.stepsByAngle(2*r);return course.parts.stripe(game.model.Path.circle(t,r,o).transform(game.geometry.Matrix.rotationY(Math.PI/2)).position(),game.model.Path.circle(t,r,o).transform(game.geometry.Matrix.rotationY(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e,0,0)))).position())},verticalPath:function(e,t,r,o){return course.parts.stripe(new game.model.Path((function(e){return new game.geometry.Vector(2,t*e,r(e))}),o),new game.model.Path((function(o){return new game.geometry.Vector(2+e,t*o,r(o))}),o))},stripe:function(e,t){const r=e.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),o=t.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),a=r.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),n=o.border(e,1,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=r.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),s=o.border(e,0,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.physics.Body.merge([game.physics.Body.fromModel(r.withColor(course.constants.COLORS.GREEN).enableChecker().stripe(o.withColor(course.constants.COLORS.GREEN).enableChecker()),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(game.utility.flatten([n.stripe(a),game.model.Triangle.polygon([{vertex:r.mapper(0).negateNormal(),opposite:2},{vertex:o.mapper(0).negateNormal()},{vertex:s.mapper(0).negateNormal(),opposite:0},{vertex:m.mapper(0).negateNormal()}]),game.model.Triangle.polygon([{vertex:m.mapper(1),opposite:2},{vertex:s.mapper(1)},{vertex:o.mapper(1),opposite:0},{vertex:r.mapper(1)}])]),course.constants.COLLISION.WALL),course.parts.walls.pathBorder(r,t,!0,!0),course.parts.walls.pathBorder(o.reverse().negateNormals(),e.reverse(),!0,!0)])},circularHub:function(e,t,r,o){const a=t.map((function(t){const r=Math.asin((t.width/2+1)/(e+1));return{opening:t,dAngle:r,pAngle:t.angle+r,nAngle:t.angle-r,length:(1-Math.cos(r))*(e+1)}}));return a.push({opening:a[0].opening,dAngle:a[0].dAngle,pAngle:a[0].pAngle+2*Math.PI,nAngle:a[0].nAngle+2*Math.PI,length:a[0].length}),game.physics.Body.merge(game.utility.flatten([t.map((function(t,r){const n=a[r],m=a[r+1],s=m.nAngle-n.pAngle;return game.physics.Body.merge([game.physics.Body.merge([course.parts.walls.pathBorder(game.model.Path.circle(e,-s,course.utility.stepsByAngle(s*o)),game.model.Path.point(new game.geometry.Vector(0,0,0))),course.parts.walls.straightElbowed(m.length,0,m.dAngle-Math.PI/2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-1,-m.length,0)).dot(game.geometry.Matrix.rotationZ(Math.PI/2+m.dAngle)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+1,0,0))))]).transform(game.geometry.Matrix.rotationZ(s)),course.parts.walls.straightElbowed(n.length,n.dAngle-Math.PI/2,0).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-1,0,0)).dot(game.geometry.Matrix.rotationZ(-Math.PI/2-n.dAngle)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+1,0,0))))]).transform(game.geometry.Matrix.rotationZ(n.pAngle))})),game.utility.flatten(t.map((function(t,r){const o=a[r],n=Math.cos(o.opening.angle),m=Math.sin(o.opening.angle),s=Math.cos(o.pAngle),g=Math.sin(o.pAngle),c=Math.cos(o.nAngle),i=Math.sin(o.nAngle),l=n*(e+1),y=m*(e+1),u=n*(o.opening.width/2+1),w=m*(o.opening.width/2+1),p=Math.cos(o.dAngle)*(e+1)-Math.tan((Math.PI/2-o.dAngle)/2),d=n*p,L=m*p,h=n*o.opening.width/2,V=m*o.opening.width/2;return[game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(s*(e+1),g*(e+1),-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(c*(e+1),i*(e+1),-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(l+w,y-u,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(l-w,y+u,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL),game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(s*e,g*e,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(d-V,L+h,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(l-V,y+h,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)},{vertex:new game.model.Vertex(new game.geometry.Vector(l+V,y-h,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(d+V,L-h,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(c*e,i*e,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)}]),course.constants.COLLISION.GREEN),course.parts.walls.straightCap(o.opening.width).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+1,-o.opening.width/2-2,0))).dot(game.geometry.Matrix.rotationZ(o.opening.angle)))]}))),[game.physics.Body.fromModel(game.model.Triangle.fan(game.utility.flatten(t.map((function(t,r){const n=a[r],m=a[r+1].nAngle-n.pAngle;return game.model.Path.circle(e+1,m,course.utility.stepsByAngle(m*o)).withNormal(new game.geometry.Vector(0,0,-1)).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.rotationZ(n.pAngle)).waypoints()})))),course.constants.COLLISION.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2))),r(game.utility.pushFirst(game.utility.flatten(t.map((function(t,r){const n=a[r],m=a[r+1].nAngle-n.pAngle;return game.model.Path.circle(e,m,course.utility.stepsByAngle(m*o)).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(n.pAngle)).waypoints()}))).reverse()),t[0].angle)]]))},circularHubVolcano:function(e,t,r,o){return function(a,n){return game.physics.Body.merge([game.physics.Body.fromModel(game.utility.flatten([game.model.Triangle.stripe(a,game.model.Path.circle(t,2*Math.PI,course.utility.curveSteps(2)).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(n)).waypoints().reverse()),new game.model.Path((function(a){const n=r*Math.pow(a,o),m=o*r*Math.pow(a,o-1);return new game.model.Vertex(new game.geometry.Vector(game.utility.interpolate(t,e,a),0,n),new game.geometry.Vector(t-e,0,-m),course.constants.COLORS.GREEN,!0)}),course.utility.curveSteps(.5)).rotateZ(2*Math.PI,course.utility.curveSteps(2)).surface()]),course.constants.COLLISION.GREEN),course.parts.hole(e,1,course.utility.curveSteps(2)).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,r)))])}}},compositions:{simpleStraight:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,49,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(10,56).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,0))),course.parts.roundHoleEnd(10,0,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(7,-7,0))))]))},verticalCurveOver:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,21,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(10,28),course.parts.verticalCurve(10,14,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(12,0,14)))),course.parts.horizontalCurve(10,9,Math.PI).transform(game.geometry.Matrix.rotationX(Math.PI/2).dot(game.geometry.Matrix.rotationZ(Math.PI)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-14,14)))),course.parts.verticalCurve(10,14,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(40,0,14)))),course.parts.rectCurve(10,14,10,14).transform(game.geometry.Matrix.translation(new game.geometry.Vector(14,14,0))),course.parts.rectCurve(10,14,10,28).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(28,28,0)))),course.parts.roundHoleEnd(10,14,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-7,0))))]))},crossJump:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,7,7),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(10,28).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,0))),course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(14,-14,0)))),course.parts.verticalPath(10,28,(function(e){return 1-Math.cos(4*Math.PI*e)}),course.utility.curveSteps(2)).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-28,0)))),course.parts.horizontalCurve(10,2,Math.PI).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0)))),course.parts.verticalPath(10,28,(function(e){return 6*Math.pow(e,2)}),course.constants.CURVE_STEPS).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0)))),course.parts.straight(10,14).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,4)))),course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-14,-14,4)))),course.parts.roundHoleEnd(10,0,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-21,-21,4))))]))},volcano:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(9,53,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(14,42).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,20,0))),course.parts.circularHub(19,[{angle:Math.PI/2,width:14}],course.parts.circularHubVolcano(2,16,6,2),2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(9,0,0))),course.parts.woods.straight([0,0,0,0],[6,5,5,6],2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(2,22,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(8,22,0))),course.parts.woods.arc(1,2,2,1,course.constants.CURVE_STEPS).transform(game.geometry.Matrix.translation(new game.geometry.Vector(9,22,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(10,24,0)))),course.parts.woods.straight([0,1,1,0],[6,6,6,6],2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(10,22,0))),course.parts.woods.straight([0,0,0,0],[2,1,1,2],2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(2,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(4,40,0))),course.parts.woods.arc(1,2,2,1,course.constants.CURVE_STEPS).transform(game.geometry.Matrix.translation(new game.geometry.Vector(5,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(6,42,0)))),course.parts.woods.straight([0,1,1,0],[6,5,5,6],2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(6,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(12,40,0))),course.parts.woods.arc(1,2,2,1,course.constants.CURVE_STEPS).transform(game.geometry.Matrix.translation(new game.geometry.Vector(13,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(14,42,0)))),course.parts.woods.straight([0,1,1,0],[2,2,2,2],2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(14,40,0)))]))}}};"undefined"!=typeof exports&&(module.exports=course);