const course={constants:{rebound:function(e,t,r){return new game.collision.handlers.Rebound(course.constants.MIN_VELOCITY,course.constants.MIN_ANGLE,e,t,r)}},parts:{quads:{xp:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[0],o[0]),new game.geometry.Vector(1,0,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[1],a[0]),new game.geometry.Vector(1,0,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[1],a[1]),new game.geometry.Vector(1,0,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[0],o[1]),new game.geometry.Vector(1,0,0),n,m)}])},xn:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[0],o[1]),new game.geometry.Vector(-1,0,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(e,r[1],a[1]),new game.geometry.Vector(-1,0,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[1],a[0]),new game.geometry.Vector(-1,0,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(e,t[0],o[0]),new game.geometry.Vector(-1,0,0),n,m)}])},yp:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],e,o[1]),new game.geometry.Vector(0,1,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],e,a[1]),new game.geometry.Vector(0,1,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],e,a[0]),new game.geometry.Vector(0,1,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],e,o[0]),new game.geometry.Vector(0,1,0),n,m)}])},yn:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],e,o[0]),new game.geometry.Vector(0,-1,0),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],e,a[0]),new game.geometry.Vector(0,-1,0),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],e,a[1]),new game.geometry.Vector(0,-1,0),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],e,o[1]),new game.geometry.Vector(0,-1,0),n,m)}])},zp:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],o[0],e),new game.geometry.Vector(0,0,1),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],a[0],e),new game.geometry.Vector(0,0,1),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],a[1],e),new game.geometry.Vector(0,0,1),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],o[1],e),new game.geometry.Vector(0,0,1),n,m)}])},zn:function(e,t,r,o,a,n,m){return game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(r[0],o[1],e),new game.geometry.Vector(0,0,-1),n,m),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(r[1],a[1],e),new game.geometry.Vector(0,0,-1),n,m)},{vertex:new game.model.Vertex(new game.geometry.Vector(t[1],a[0],e),new game.geometry.Vector(0,0,-1),n,m),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(t[0],o[0],e),new game.geometry.Vector(0,0,-1),n,m)}])}},walls:{straight:function(e,t){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.xn(1,[e[0],e[0]],[t[0],t[0]],[-2,-2],[1,1],course.constants.COLORS.WALL),course.parts.quads.zp(1,[1,1],[2,2],e,t,course.constants.COLORS.WALL),course.parts.quads.xp(2,[e[1],e[1]],[t[1],t[1]],[0,0],[1,1],course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)},elbowLeft:function(e,t){const r=Math.tan(e/2),o=Math.cos(e),a=Math.sin(e);return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2,r,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(1,0,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1+o,a,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1+o,a,1),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(1+o,a,t),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2,r,t),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(2,r,1),new game.geometry.Vector(o,a,0),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL)},elbowRight:function(e,t){const r=Math.tan(e/2),o=Math.cos(e),a=Math.sin(e);return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(2-o,a,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(2,0,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,r,1),new game.geometry.Vector(0,0,1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(1,r,1),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(1,r,t),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(2-o,a,t),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(2-o,a,1),new game.geometry.Vector(-o,a,0),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL)},elbowBoth:function(e,t,r){return e>0?course.parts.walls.elbowRight(e,t):e<0?course.parts.walls.elbowLeft(-e,r):game.physics.Body.EMPTY},straightElbowed:function(e,t,r){const o=Math.tan(t/2),a=Math.tan(r/2);return game.physics.Body.merge([course.parts.walls.straight([Math.min(-o,0),Math.min(o,0)],[e+Math.max(a,0),e+Math.max(-a,0)]),course.parts.walls.elbowBoth(-t,0,-2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(3,0,0)))),course.parts.walls.elbowBoth(r,-2,0).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,e,0)))])},pathBorder:function(e,t,r,o){const a=e.withColor(course.constants.COLORS.WALL),n=a.border(t,0,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=a.border(t,1,1).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),s=a.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),g=a.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.physics.Body.fromModel(game.utility.flatten([s.stripe(m),m.stripe(n),n.stripe(a),r?game.model.Triangle.polygon([{vertex:g.mapper(0).negateNormal(),opposite:2},{vertex:s.mapper(0).negateNormal()},{vertex:m.mapper(0).negateNormal(),opposite:0},{vertex:n.mapper(0).negateNormal()}]):[],o?game.model.Triangle.polygon([{vertex:n.mapper(1),opposite:2},{vertex:m.mapper(1)},{vertex:s.mapper(1),opposite:0},{vertex:g.mapper(1)}]):[]]),course.constants.COLLISION.WALL)},straightCap:function(e){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.yn(0,[1,1],[2,2],[-2,0],[1,1],course.constants.COLORS.WALL),course.parts.quads.yn(0,[1,2],[e+3,e+2],[-2,-2],[0,0],course.constants.COLORS.WALL),course.parts.quads.yn(0,[e+2,e+2],[e+3,e+3],[0,-2],[1,1],course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)}},woods:{straight:function(e,t,r,o){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.yn(0,e.slice(0,2),t.slice(0,2),[0,0],[o,o],course.constants.COLORS.WOOD),course.parts.quads.zp(o,e.slice(1,3),t.slice(1,3),[0,0],[r,r],course.constants.COLORS.WOOD),course.parts.quads.yp(r,e.slice(2,4).reverse(),t.slice(2,4).reverse(),[0,0],[o,o],course.constants.COLORS.WOOD)]),course.constants.COLLISION.WOOD)},cap:function(e,t,r,o){return game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.xp(0,[0,0],[e,e],[0,0],[r,r],course.constants.COLORS.WOOD),[new game.model.Triangle(new game.model.Vertex(new game.geometry.Vector(0,0,r),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(0,0,0),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(-t,0,o),new game.geometry.Vector(0,-1,0),course.constants.COLORS.WOOD)),new game.model.Triangle(new game.model.Vertex(new game.geometry.Vector(0,e,0),new game.geometry.Vector(0,1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(0,e,r),new game.geometry.Vector(0,1,0),course.constants.COLORS.WOOD),new game.model.Vertex(new game.geometry.Vector(-t,e,o),new game.geometry.Vector(0,1,0),course.constants.COLORS.WOOD))]]),course.constants.COLLISION.WOOD)},ramp:function(e,t,r){const o=new game.geometry.Vector(-r,0,t).normalize();return game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(0,0,0),o,course.constants.COLORS.WOOD),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(0,e,0),o,course.constants.COLORS.WOOD)},{vertex:new game.model.Vertex(new game.geometry.Vector(t,e,r),o,course.constants.COLORS.WOOD),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(t,0,r),o,course.constants.COLORS.WOOD)}]),course.constants.COLLISION.WOOD)},arc:function(e,t,r,o){const a=game.model.Path.circle(e,Math.PI).withColor(course.constants.COLORS.WOOD).transform(game.geometry.Matrix.rotationX(Math.PI/2)),n=game.model.Path.circle(t,Math.PI).withColor(course.constants.COLORS.WOOD).transform(game.geometry.Matrix.rotationX(Math.PI/2)),m=a.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,o))),s=a.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,r,o))),g=n.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,o))),c=n.transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,r,o)));return game.physics.Body.fromModel(game.utility.flatten([m.stripe(g),g.stripe(c),c.stripe(s),s.stripe(m)]),course.constants.COLLISION.WOOD)},bridge:function(e,t,r,o,a){return game.physics.Body.merge([course.parts.woods.straight([0,o,o,0],[t,t-a,t-a,t],e,r),course.parts.woods.ramp(e,o,.5),course.parts.woods.ramp(e,a,.5).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(t,e,0)))),game.physics.Body.fromModel(course.parts.quads.zn(0,[0,0],[t,t],[0,0],[e,e],course.constants.COLORS.WOOD),course.constants.COLLISION.WOOD)])}},hole:function(e,t){const r=game.model.Path.circle(e,2*Math.PI),o=game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-t));return game.physics.Body.merge([game.physics.Body.fromModel(r.withColor(course.constants.COLORS.HOLE).transform(o).stripe(r.withColor(course.constants.COLORS.HOLE)),course.constants.COLLISION.HOLE.WALL),game.physics.Body.fromModel(r.withColor(course.constants.COLORS.WALL).withNormal(new game.geometry.Vector(0,0,1)).transform(o).reverse().truncate(1).fan(),course.constants.COLLISION.HOLE.FLOOR)])},roundHoleEnd:function(e,t,r){const o=game.model.Path.circle(r,2*Math.PI).withColor(course.constants.COLORS.GREEN).withNormal(new game.geometry.Vector(0,0,1)).enableChecker().waypoints(),a=Math.floor(o.length/2);return game.physics.Body.merge([course.parts.walls.pathBorder(game.model.Path.circle(e/2,Math.PI).reverse().negateNormals(),game.model.Path.point(new game.geometry.Vector(0,0,0))),game.physics.Body.merge([course.parts.walls.straight([0,0],[e/2+t+2,e/2+t+2]),course.parts.walls.straightCap(e)]).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-e/2-2,-e/2-t-2,0))),course.parts.walls.straight([0,0],[e/2+t+2,e/2+t+2]).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e/2+2,0,0)))),game.physics.Body.fromModel(game.model.Triangle.stripe(game.model.Path.circle(e/2+1,Math.PI).withNormal(new game.geometry.Vector(0,0,-1)).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2))).waypoints(),[new game.model.Vertex(new game.geometry.Vector(e/2+1,-e/2-t-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),new game.model.Vertex(new game.geometry.Vector(-e/2-1,-e/2-t-2,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL),game.physics.Body.fromModel(game.utility.flatten([game.model.Triangle.stripe(o.slice(0,a+1),game.model.Path.circle(e/2,Math.PI).withColor(course.constants.COLORS.GREEN).withNormal(new game.geometry.Vector(0,0,1)).enableChecker().waypoints()),game.model.Triangle.stripe(o.slice(a),[new game.model.Vertex(new game.geometry.Vector(-e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(-e/2,-e/2-t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,-e/2-t-2,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),new game.model.Vertex(new game.geometry.Vector(e/2,0,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)])]),course.constants.COLLISION.GREEN),course.parts.hole(r,1)])},straight:function(e,t){return course.parts.verticalPath(e,t,(function(e){return 0}))},rectEnd:function(e,t){return game.physics.Body.merge([course.parts.walls.straight([0,0],[t-1,t-2]),course.parts.walls.straight([-1,0],[t-2,t-2]).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-2,0)))),course.parts.walls.straight([-1,0],[e+1,e]).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0)))),course.parts.walls.straightCap(e),game.physics.Body.fromModel(course.parts.quads.zp(0,[2,2],[e+2,e+2],[0,0],[t-2,t-2],course.constants.COLORS.GREEN,!0),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(course.parts.quads.zn(-2,[1,1],[e+3,e+3],[0,0],[t-1,t-1],course.constants.COLORS.WALL),course.constants.COLLISION.WALL)])},rectCurve:function(e,t,r,o){return game.physics.Body.merge([course.parts.walls.straight([0,0],[t-1,t-2]),course.parts.walls.straight([-1,0],[o-2,o-2]).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(2,t,0)))),course.parts.walls.straight([1,0],[t-r-2,t-r-2]).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+4,t-r-2,0)))),course.parts.walls.straight([0,0],[o-e-3,o-e-2]).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(o,t-r-4,0)))),course.parts.walls.straightCap(e),course.parts.walls.straightCap(r).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(o,t-r-4,0)))),game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.zp(0,[2,2],[e+2,e+2],[0,0],[t-2,t-r-2],course.constants.COLORS.GREEN,!0),course.parts.quads.zp(0,[e+2,2],[o,o],[t-r-2,t-r-2],[t-2,t-2],course.constants.COLORS.GREEN,!0)]),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(game.utility.flatten([course.parts.quads.zn(-2,[1,1],[e+3,e+3],[0,0],[t-1,t-r-3],course.constants.COLORS.WALL),course.parts.quads.zn(-2,[e+3,1],[o,o],[t-r-3,t-r-3],[t-1,t-1],course.constants.COLORS.WALL)]),course.constants.COLLISION.WALL)])},horizontalCurve:function(e,t,r){return course.parts.stripe(game.model.Path.circle(t,r).position(),game.model.Path.circle(t+e,r).position())},verticalCurve:function(e,t,r){return course.parts.stripe(game.model.Path.circle(t,r).transform(game.geometry.Matrix.rotationY(Math.PI/2)).position(),game.model.Path.circle(t,r).transform(game.geometry.Matrix.rotationY(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e,0,0)))).position())},verticalPath:function(e,t,r){return course.parts.stripe(game.model.Path.auto((function(e){return new game.geometry.Vector(2,t*e,r(e))})),game.model.Path.auto((function(o){return new game.geometry.Vector(2+e,t*o,r(o))})))},stripe:function(e,t){const r=e.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),o=t.vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),a=r.border(t,1,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),n=o.border(e,1,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),m=r.border(t,0,-2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA),s=o.border(e,0,2).vertex().withColor(course.constants.COLORS.WALL).normalize(course.constants.NORMAL_DELTA);return game.physics.Body.merge([game.physics.Body.fromModel(r.withColor(course.constants.COLORS.GREEN).enableChecker().stripe(o.withColor(course.constants.COLORS.GREEN).enableChecker()),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(game.utility.flatten([n.stripe(a),game.model.Triangle.polygon([{vertex:r.mapper(0).negateNormal(),opposite:2},{vertex:o.mapper(0).negateNormal()},{vertex:s.mapper(0).negateNormal(),opposite:0},{vertex:m.mapper(0).negateNormal()}]),game.model.Triangle.polygon([{vertex:m.mapper(1),opposite:2},{vertex:s.mapper(1)},{vertex:o.mapper(1),opposite:0},{vertex:r.mapper(1)}])]),course.constants.COLLISION.WALL),course.parts.walls.pathBorder(r,t,!0,!0),course.parts.walls.pathBorder(o.reverse().negateNormals(),e.reverse(),!0,!0)])},circularPlatform:function(e){const t=game.model.Path.circle(e,2*Math.PI),r=game.model.Path.circle(e,2*Math.PI).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2)));return game.physics.Body.merge([game.physics.Body.fromModel(t.withColor(course.constants.COLORS.WALL).stripe(r.withColor(course.constants.COLORS.WALL)),course.constants.COLLISION.WALL),game.physics.Body.fromModel(t.withColor(course.constants.COLORS.GREEN).withNormal(new game.geometry.Vector(0,0,1)).enableChecker().reverse().truncate(1).fan(),course.constants.COLLISION.GREEN),game.physics.Body.fromModel(r.withColor(course.constants.COLORS.WALL).withNormal(new game.geometry.Vector(0,0,-1)).truncate(1).fan(),course.constants.COLLISION.WALL)])},circularHub:function(e,t,r){const o=t.map((function(t){const r=Math.asin((t.width/2+1)/(e+1));return{opening:t,dAngle:r,pAngle:t.angle+r,nAngle:t.angle-r,length:(1-Math.cos(r))*(e+1)}}));return o.push({opening:o[0].opening,dAngle:o[0].dAngle,pAngle:o[0].pAngle+2*Math.PI,nAngle:o[0].nAngle+2*Math.PI,length:o[0].length}),game.physics.Body.merge(game.utility.flatten([t.map((function(t,r){const a=o[r],n=o[r+1],m=n.nAngle-a.pAngle;return game.physics.Body.merge([game.physics.Body.merge([course.parts.walls.pathBorder(game.model.Path.circle(e,-m),game.model.Path.point(new game.geometry.Vector(0,0,0))),course.parts.walls.straightElbowed(n.length,0,n.dAngle-Math.PI/2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-1,-n.length,0)).dot(game.geometry.Matrix.rotationZ(Math.PI/2+n.dAngle)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+1,0,0))))]).transform(game.geometry.Matrix.rotationZ(m)),course.parts.walls.straightElbowed(a.length,a.dAngle-Math.PI/2,0).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-1,0,0)).dot(game.geometry.Matrix.rotationZ(-Math.PI/2-a.dAngle)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+1,0,0))))]).transform(game.geometry.Matrix.rotationZ(a.pAngle))})),game.utility.flatten(t.map((function(t,r){const a=o[r],n=Math.cos(a.opening.angle),m=Math.sin(a.opening.angle),s=Math.cos(a.pAngle),g=Math.sin(a.pAngle),c=Math.cos(a.nAngle),i=Math.sin(a.nAngle),l=n*(e+1),y=m*(e+1),u=n*(a.opening.width/2+1),w=m*(a.opening.width/2+1),p=Math.cos(a.dAngle)*(e+1)-Math.tan((Math.PI/2-a.dAngle)/2),d=n*p,L=m*p,O=n*a.opening.width/2,V=m*a.opening.width/2;return[game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(s*(e+1),g*(e+1),-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:2},{vertex:new game.model.Vertex(new game.geometry.Vector(c*(e+1),i*(e+1),-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)},{vertex:new game.model.Vertex(new game.geometry.Vector(l+w,y-u,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL),opposite:0},{vertex:new game.model.Vertex(new game.geometry.Vector(l-w,y+u,-2),new game.geometry.Vector(0,0,-1),course.constants.COLORS.WALL)}]),course.constants.COLLISION.WALL),game.physics.Body.fromModel(game.model.Triangle.polygon([{vertex:new game.model.Vertex(new game.geometry.Vector(s*e,g*e,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:5},{vertex:new game.model.Vertex(new game.geometry.Vector(d-V,L+O,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:3},{vertex:new game.model.Vertex(new game.geometry.Vector(l-V,y+O,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)},{vertex:new game.model.Vertex(new game.geometry.Vector(l+V,y-O,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(d+V,L-O,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0),opposite:1},{vertex:new game.model.Vertex(new game.geometry.Vector(c*e,i*e,0),new game.geometry.Vector(0,0,1),course.constants.COLORS.GREEN,!0)}]),course.constants.COLLISION.GREEN),course.parts.walls.straightCap(a.opening.width).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(e+1,-a.opening.width/2-2,0))).dot(game.geometry.Matrix.rotationZ(a.opening.angle)))]}))),[game.physics.Body.fromModel(game.model.Triangle.fan(game.utility.flatten(t.map((function(t,r){const a=o[r],n=o[r+1].nAngle-a.pAngle;return game.model.Path.circle(e+1,n).withNormal(new game.geometry.Vector(0,0,-1)).withColor(course.constants.COLORS.WALL).transform(game.geometry.Matrix.rotationZ(a.pAngle)).waypoints()})))),course.constants.COLLISION.WALL).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,-2))),r(game.utility.pushFirst(game.utility.flatten(t.map((function(t,r){const a=o[r],n=o[r+1].nAngle-a.pAngle;return game.model.Path.circle(e,n).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(a.pAngle)).waypoints()}))).reverse()),t[0].angle)]]))},circularHubVolcano:function(e,t,r,o){return function(a,n){return game.physics.Body.merge([game.physics.Body.fromModel(game.utility.flatten([game.model.Triangle.stripe(a,game.model.Path.circle(t,2*Math.PI).withNormal(new game.geometry.Vector(0,0,1)).withColor(course.constants.COLORS.GREEN).enableChecker().transform(game.geometry.Matrix.rotationZ(n)).waypoints().reverse()),game.model.Path.autoVertex((function(a){const n=r*Math.pow(a,o),m=o*r*Math.pow(a,o-1);return new game.model.Vertex(new game.geometry.Vector(0,game.utility.interpolate(t,e,a),n),new game.geometry.Vector(0,t-e,-m),course.constants.COLORS.GREEN,!0)})).rotateZ(-2*Math.PI).surface()]),course.constants.COLLISION.GREEN),course.parts.hole(e,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,r)))])}}},compositions:{simpleStraight:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,49,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(10,56).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,0))),course.parts.roundHoleEnd(10,0,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(7,-7,0))))]))},verticalCurveOver:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,21,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(10,28),course.parts.verticalCurve(10,14,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(12,0,14)))),course.parts.horizontalCurve(10,9,Math.PI).transform(game.geometry.Matrix.rotationX(Math.PI/2).dot(game.geometry.Matrix.rotationZ(Math.PI)).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-14,14)))),course.parts.verticalCurve(10,14,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(40,0,14)))),course.parts.rectCurve(10,14,10,14).transform(game.geometry.Matrix.translation(new game.geometry.Vector(14,14,0))),course.parts.rectCurve(10,14,10,28).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(28,28,0)))),course.parts.roundHoleEnd(10,14,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(21,-7,0))))]))},crossJump:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,7,7),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(10,28).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,0))),course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(14,-14,0)))),course.parts.verticalPath(10,28,(function(e){return 1-Math.cos(4*Math.PI*e)})).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-28,0)))),course.parts.horizontalCurve(10,2,Math.PI).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0)))),course.parts.verticalPath(10,28,(function(e){return 6*Math.pow(e,2)})).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(42,-14,0)))),course.parts.straight(10,14).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(0,-14,4)))),course.parts.horizontalCurve(10,2,Math.PI/2).transform(game.geometry.Matrix.rotationZ(Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-14,-14,4)))),course.parts.roundHoleEnd(10,0,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-21,-21,4))))]))},volcano:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(9,53,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(14,42).transform(game.geometry.Matrix.translation(new game.geometry.Vector(0,20,0))),course.parts.circularHub(19,[{angle:Math.PI/2,width:14}],course.parts.circularHubVolcano(2,16,6,2)).transform(game.geometry.Matrix.translation(new game.geometry.Vector(9,0,0))),course.parts.woods.straight([0,0,0,0],[6,5,5,6],2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(2,22,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(8,22,0))),course.parts.woods.arc(1,2,2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(9,22,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(10,24,0)))),course.parts.woods.straight([0,1,1,0],[6,6,6,6],2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(10,22,0))),course.parts.woods.straight([0,0,0,0],[2,1,1,2],2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(2,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(4,40,0))),course.parts.woods.arc(1,2,2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(5,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(6,42,0)))),course.parts.woods.straight([0,1,1,0],[6,5,5,6],2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(6,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(12,40,0))),course.parts.woods.arc(1,2,2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(13,40,0))),course.parts.woods.cap(2,1,1,1).transform(game.geometry.Matrix.rotationZ(Math.PI).dot(game.geometry.Matrix.translation(new game.geometry.Vector(14,42,0)))),course.parts.woods.straight([0,1,1,0],[2,2,2,2],2,1).transform(game.geometry.Matrix.translation(new game.geometry.Vector(14,40,0)))]))},bridgedIslands:function(){return new game.physics.Course(new game.physics.Motion(new game.geometry.Vector(7,-7,game.physics.Ball.SPHERE.radius),new game.geometry.Vector(0,0,0)),game.physics.Body.merge([course.parts.rectEnd(24,14).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(0,0,0)))),course.parts.circularPlatform(10).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-28,-20,0))),course.parts.circularPlatform(8).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-18,-48,0))),course.parts.roundHoleEnd(8,0,1).transform(game.geometry.Matrix.rotationZ(-Math.PI/2).dot(game.geometry.Matrix.translation(new game.geometry.Vector(8,-48,0)))),course.parts.woods.bridge(4,26,.5,0,4).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-22,-22,0))),course.parts.woods.bridge(6,16,.5,3,0).transform(game.geometry.Matrix.translation(new game.geometry.Vector((new game.geometry.Vector(28,10,0).length()-16)/2+1,-3,0)).dot(game.geometry.Matrix.rotationZ(-Math.atan(2.8))).dot(game.geometry.Matrix.translation(new game.geometry.Vector(-28,-20,0)))),course.parts.woods.bridge(4,16,.5,2,2).transform(game.geometry.Matrix.translation(new game.geometry.Vector(-12,-50,0)))]))}}};course.constants.MIN_VELOCITY=1,course.constants.MIN_ANGLE=.05,course.constants.NORMAL_DELTA=.01,course.constants.COLORS={GREEN:new game.model.Color(.4,.8,.2),WALL:new game.model.Color(.8,.8,.8),WOOD:new game.model.Color(.7,.5,0),HOLE:new game.model.Color(1,1,1)},course.constants.COLLISION={GREEN:course.constants.rebound(.4,.001,.05),WALL:course.constants.rebound(.6,.001,.02),WOOD:course.constants.rebound(.5,.001,.04),HOLE:{WALL:course.constants.rebound(.3,.001,.1),FLOOR:new game.collision.handlers.Collection([course.constants.rebound(.2,.001,.2),game.collision.handlers.Static.BALL_COMPLETION])}},"undefined"!=typeof exports&&(module.exports=course);